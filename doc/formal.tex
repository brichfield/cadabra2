\documentclass[11pt]{article}
\usepackage{geometry}
\usepackage{listings}
\usepackage[colorlinks=true, citecolor=red, linkcolor=blue, urlcolor=red, plainpages=false, pdfpagelabels]{hyperref}
\usepackage{xcolor}
%\usepackage[T1]{fontenc}
%\usepackage{fourier}
%\usepackage{baskervald}
\usepackage{charter}
\usepackage{relsize}
%\usepackage[urw-garamond]{mathdesign}
%\usepackage[T1]{fontenc}
%\usepackage[osf]{mathpazo}
%\usepackage{libertine}
%\usepackage{librebaskerville}
%\usepackage[T1]{fontenc}
%\usepackage[T1]{fontenc}
%\usepackage{stix}
%\usepackage[garamond]{mathdesign}
%\usepackage{fontspec}
%\setmainfont{stone_serif_regular}

\lstset{basicstyle=\small\color{black!60}\ttfamily, 
        breaklines=true,
        columns=fullflexible,
        commentstyle=\color{gray!60},
        numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt
       }

\begin{document}
\pagestyle{empty}
\begin{flushright}
arxiv:xxxx.xxxx\\
2014
\end{flushright}
\vskip 7ex

\begin{center}
\begin{minipage}{.95\textwidth}
{\Large\larger\bf Cadabra II: tensor computer algebra reborn}\\[7ex]
{\large\bf Kasper Peeters}\\[5ex]
Department of Mathematical Sciences\\
Durham University\\
South Road\\
Durham DH1 3LE\\
United Kingdom\\[3ex]
{\tt kasper.peeters@durham.ac.uk}
\vskip 9ex

{\bf Abstract:}\\[1ex] 

\end{minipage}

\vfill\vfill

\begin{minipage}{0.95\textwidth}
\noindent{\smaller\smaller This paper describes the capabilities of
  the Cadabra~II computer algebra system; the software itself, including
  source code, can be obtained from
  \url{http://cadabra.phi-sci.com/} where further
  documentation can also be found.}
\end{minipage}
\end{center}
\eject
\pagestyle{plain}
\hrule
\tableofcontents
\vspace{4ex}
\hrule
\bigskip



\section{Philosophy of Cadabra and overview of the new version}

- Python module 'cadabra', accessible from normal Python and
e.g. IPython.
- Python shell with facility to use cadabra language together with
python.
- Server which can execute mixed cadabra/python code blobs and keep
state.
- Document library which forms basis of client.
- GUI layer which displays the document objects.


\section{Showcases: what you could not do before}
\subsection{Advanced general relativity}
\subsection{Machine vision}
\subsection{Materials science}

\section{What's new}
\subsection{End user visible changes}
\subsubsection{Integrate abstract index, form and component computations}

There are, in fact, very few systems that handle abstract and
component computations equally well.

Also include purely numerical components so we can run computer vision
algorithms. Requires pre-parsing and pre-computing of expressions.

The strength of cadabra's component engine comes from the fact that it
integrates seamlessly with abstract computations, and can handle
components of any data type, from purely abstract via functional down
to numerical.

Code generation, be able to write abstract tensor expressions
including e.g.~derivatives and then stick component functions in, and
then output as C code. See
\url{http://groups.google.com/group/sympy/t/ee93372bf4d28443}
and compare also Theano and in particular the
very readable \url{http://www.iro.umontreal.ca/~lisa/pointeurs/theano_scipy2010.pdf}
(write out what the example there means in terms of component functions).

C++: \cite{ltensor},\cite{ftensor}.
Matlab: \cite{TTB_Software}.
Mathematica: \cite{kranc}

Algorithm: walk down the tree depth first. At the lowest tensor, make
a sparse map from all values of the free indices at that level to the
value of the tensor components. Store this map associated to the
node. Iterate over the tree.

Exterior calculus \cite{xTerior}. Need to be able to use '$\wedge$'
notation. Maybe a 'Form' property which carries a degree parameter.


\subsubsection{Notebook \LaTeX{} customisation}

Enable inclusion of other packages and customisation of typesetting of expressions.

\subsubsection{Community}

Make it easier for 3rd party developers to add packages in the form of
Python code. For this we would have to give the Python code access to
the C++ tree. Can that be done safely? We also 

\subsubsection{Rethink spinors}

\subsubsection{Separate the data language from the programming language}

When manipulating html, do you write your program in html as well?
When manipulating images, do you draw your code as an image? These
examples show that it often makes sense to distinguish the programming
language from the data language.

Most existing computer algebra systems assume that all maths can
sensibly be transformed into a language of `functions applying to
functions'. They hence conclude that for manipulation of mathematical
formula, it is fine to use the same language to write the program as
you do to write the mathematical expressions on which you want the
program to act. Now this assumption certainly is true for a decent
subset of mathematics. It is, unfortunately, not true in
general. Tensor algebra in particular is just plain ugly and messy in
this sort of notation.

A good example of how difficult things become when you insist on 
representing your mathematical expressions inside your programming language,
is additional assumptions. How do you write an expression which has the
additional hidden assumption that certain indices are symmetrised? 
You cannot attach that kind of information to an equation object, because you may 
want to attach it to any kind of expression. So you are forced to represent
any expression as
\begin{verbatim}
  Expression[ A[m,n], assumptions={Symmetric[{m,n}]} ]
\end{verbatim}
or something like that. But now you \emph{have} to wrap any expression
in some wrapper object to keep assumptions togeter. Why not then write
the expression in a different language altogether?

\subsubsection{Make algorithms accessible from multiple languages}

One advantage that single-language systems like described in the
previous section have is that the algorithms used to manipulate the
data are at the same time usable 'internally' in programs. An good
example is the use of permutation groups -> lists.

\subsubsection{Make algorithms explain what they do}

A clean logging channel which can be viewed and inspected for problems.


\subsubsection{Provide a full-fledged programming language}



\subsubsection{Rethink the notebook interface}

Is the 'we can execute the notebook in any order' paradigm a good one?
See the IPython discussion recently. Notebooks have not changed much;
there is room for a more 2d approach in which example snippets or
tutorials can be seen at the same time as the main notebook.

Useful: lock a cell to the screen, effectively splitting the screen in
two. 

Import notebook into another. 

\subsubsection{Make progress update more central}

In an interactive environment it is extremely useful to have a
progress indicator. It is also important that any long-running
computation can be interrupted without destroying the current state of
the expression tree (i.e.~reverting to the state of the system before
the computation was started). 

TODO: We now enforce much more strictly that algorithms can only touch the
data below the top node that they are given, by isolating this data in
a separate exptree object and then handing only that exptree object to
the algorithm. Algorithms run in threads, so that the main kernel
never blocks.

\subsubsection{Make the backend cell-based}

The original version was driven by line-by-line input, 

\subsubsection{More automatic simplification}

Cadabra was very conservative in the number of simplifications it made
to its output. Even simple things like setting derivatives of
numbers equal to zero, or collecting equal terms, had to be done
manually or had to be added explicitly to the post-processing
simplification rules.

Post-processing is now a python function, and its default
implementation has a larger number of simplifications based on user
feedback. 

% @unwrap constants
% @collect terms
% ...

\subsection{Fourier transforms and integration by parts}

Require integral, allow for easy conversion of derivatives. Is
equivalence under partial integration also expressible as a symmetry
operation? Take one integral with a derivative, express it as the
'integrated by parts symmetrised version', then doing that for two
terms in a sum shows that they are equivalent.

\subsection{Canonicalisation}

Also think about integration by parts, decompose on basis logic. See above.


%-------------------------------------------------------------------
\subsection{Internal changes}
\subsubsection{Use CMake}

This does not require much explanation: the original make + libtool
solution is incredibly difficult to get right on all platforms, and
CMake has grown into a nice and mature build system that just works.

\subsubsection{Shy away from cross-platform GUI toolkits}

Cadabra's graphical notebook interface was written using Gtkmm, which
was, and still is, an excellent choice on Linux. It turned out to be a
total horror on Windows (leading me to abandon that platform
altogether), and still caused quite a number of problems on OS X.  I
have briefly considered using a cross-platform GUI toolkits such as Qt
or wxWindows for version 2. However, none of them `do one thing, and
do it well', most are horribly bloated, and none of them look properly
native on all three major platforms. I have thus decided to design the
GUI layer to be as thin as possible, and write it on each platform
separately using the native toolkits.

The main problem with not using a web interface is that more work is
necessary for nice output. 

%------------------------------------------------------------------
\subsection{Things intentionally kept unchanged}
\subsubsection{Retain the property type system}

Cadabra's type system is prototype-based, in contrast to the
class-based approach followed by many other systems (e.g.~sympy). 
The key ingredient is not the class, but rather its properties.
The idea of the property system was the objects can have multiple,
unrelated properties, which do not fit well when implemented in terms
of a single object class. An example will clarify this. Consider the
definition of $\mu$ and $\nu$ as being indices. In Cadabra you do
\begin{quote}
%{\mu,\nu}::Indices.
\end{quote}
You may also need to know that these indices are integers ranging from
zero to three. You would do
\begin{quote}
%{\mu,\nu}::Integer(0..3).
\end{quote}
Now we could of course make this information part of the Indices
object through inheritance: an index is also an integer. But this has
two disadvantages. First of all, you may never need the information
about an index being an integer. In many cases, this is simply
additional data dragged along for no reason. But secondly, this means
that the class hierarchy must know in advance all properties that an
object can have. More complicated objects, e.g.~the Riemann tensor,
will have loads of inherited objects to cover all the possible
properties that this tensor may have. Many of those will never be
needed, and there will always be additional properties which we have
not thought about. 

The problem with trying to capture mathematics into a class-based
approach is that this is quickly turning into a nightmare. Mathematics
forms an enormous hierarchy, and getting it right is very
complex. However, it is rarely necessary to need all that in practical
computations. I do not need to know that integers form a field
etc. With a class-based system, you would first make this hierarchy
and then use it. With a property or prototype-based system, you can
pick the properties you need without worrying about the others.

%In the new parser we should be more flexible with white-space and
%allow ``{\mu,\nu} :: Indices.'' as well.


On the other hand, it has often been annoying having to specify
properties for objects both with their upper and lower indices,
e.g.~for symmetric or anti-symmetric tensors. This should be improved.

\subsubsection{Make the take/replace match logic more central}

In v1 there are many commands which are like substitutions, and which
would make sense in take/replace match, e.g. keep\_weight. 

\subsubsection{Infer rules for tensors with different index positions}

E.g. make \verb|g^{a b}::Depends(\partial).| when it has already been
declared to depend on the derivative when it is written with lower
indices. Ditto for symmetries. xAct has SeparateMetric which I think
moves indices down in exchange for explicit inverse metrics? Their
MakeRule makes rules for all possible index positions, no? See the
samples in the xAct:1429 thread.



\subsubsection{Aim for backward compatibility}


\subsubsection{Keep it simple}


xExtras

\subsection{Structure of expressions}

To note:
\begin{itemize}
\item For a variety of reasons it is make precise when a node is ``a
  term in a sum'' or ``a factor in a product''; the reason being that
  a node being zero only influences a single term in a sum but it
  influences all factors in a product. 

\item Related to the above: many structure-probing functions currently
  use ``parent'' without taking proper care of the fact that the
  parent may be a wrapping ``Accent'' or ``Derivative''. 

\item This is captured by ``term-like'' and ``factor-like''. The main
  complication here is to make precise how far up we should go in the
  tree. Probably just one step. ``Accent'' nodes should handle their
  zero coefficients themselves, not rely on their child nodes to do
  it. Single terms in an expression (e.g.~an expression which is just
  ``A'') should also classify as term-like.
\end{itemize}

\subsection{Source and documentation structure}

The source tree follows the logic that files are either part of the
small core, or they contain an algorithm, or they contain a property. 
\begin{verbatim}
src/properties
src/algorithms
\end{verbatim}

\subsection{Localisation of algorithms}

\begin{itemize}
\item Many algorithms be in a situation in which the called
  node is a sum which ends up having zero or one terms. The logic of
  propagating this should always be: you can touch everything at or
  below the node, but you cannot remove the node, only set its
  coefficient to zero. 

\item However, whether or not a node becomes zero may be a function of
  the parent node (example: varying a term should keep it intact if
  the parent is a product-like node, but should remove it if it is a
  sum-like node. See above.

\item All algorithms should always return a consistent
  tree. Therefore, it is for instance not allowed to return with the
  iterator pointing to a sum node with zero coefficients (sum node
  with non-unit multiplier error), the algorithm has to change this to
  something valid.

\end{itemize}

% http://www.pgbovine.net/ipython-notebook-first-impressions.htm

%-------------------------------------------------------------------
%\section{Support}
%
%Stackoverflow cadabra?

%-------------------------------------------------------------------
\section{Python interface}

In earlier versions, Cadabra contained its own small (and extremely
limited) programming language. In the design of version 2, a decision
was made to replace this language with Python. This not only gives
much better structural control over expression manipulation, but it
also makes it much easier to extend Cadabra with new functionality.

Python is not ideal either, of course. Its object model is bolted-on.
Using indentation for scoping can be plain annoying.  But as a
language to write programs which are not likely going to be thousands
of lines long (users of cadabra are unlikely to write such long code),
it is perfectly fine. And it interfaces with C++ beautifully through
boost.python. Of course, Python's variable assignment model is
rubbish,
\url{http://rg03.wordpress.com/2007/04/21/semantics-of-python-variable-names-from-a-c-perspective/}.

Mixing active nodes into the expression tree has disappeared. This is
an ugly mix of programming and data language, which I want to avoid.


\subsection{Keeping expression input simple}

In the original cadabra language, you can start straightaway by
entering a mathematical expression on the first line, but you can also
start with code.  This is possible because the programming language
and the manipulation language are part of the same structure. By

In Cadabra V2, the decision was made to split input into cells which
can have a different `language' attached to them. You can enter a
mathematical expression, in which case the attached language is
`cadabra'. Or you can enter a bit of Python code, in which case the
attached language is `python'. How to glue.

\subsection{Python data types}

\begin{description}
\item[{\tt Ex}] 
\end{description}


\begin{lstlisting}
from cadabra import *

Symmetric('A_{m n}')
a = Ex('A_{m n} B^{m n}');
for t in split_factors(a):
    canonicalise(t)
\end{lstlisting}

The {\tt cadabra} function calls provide you with a handle on a
Cadabra input cell.

\begin{lstlisting}
TableauSymmetric('A_{m n}', [0,1])
a = Ex('A_{m n} B^{m n}')

for t in split_factors(a):
   print t   
\end{lstlisting}


\subsection{Sympy integration}

\begin{lstlisting}
from sympy import *
\end{lstlisting}


\subsection{IPython considerations}

The notebook paradigm as implemented by IPython has a number of
problems. First of all, it encourages coding without any structure, in
the form of a long list of sequential commands and a polluted global
namespace. Do you remember whether you already used variable
'myresult' somewhere near the top when you are working 20 pages down
the notebook? You should not have to, as this should be a local
variable. The problem is of course that, in order to use results from
one cell in the next, making everything global is the most trivial way
to do it. If you want, current notebook interfaces allow you to
declare local variables, but you have to do something special
(e.g.~use 'Module' in Mathematica). Local should be the default.

The second problem is that both IPython and Mathematica are very much
tuned to a single programming and data language. Granted, IPython has
'cell magic' which allows you to run things in other languages, but a
mix-and-match using different languages is not well supported. It is
especially problematic if you want to use the result of one cell as
input for another cell.

Another problem, which may be relatively easy to fix in ipython, but
is a problem nevertheless, is the focus on a single view of the
notebook. There is no way to open multiple views on different sections
of your notebook. Mathematica has this problem as well.

Web interfaces require re-inventing the wheel.

% \section{Migration from version 1 to 2}
% 
% All version 1 notebooks can be converted easily to version 2 notebooks by 
% keeping the following guidelines in mind.
% \begin{enumerate}
% \item Some algorithms have changed their name to something more descriptive
% and less abbreviated, e.g.~{\tt prodflatten} now reads {\tt flatten\_product}.
% \item 
% \end{enumerate}

\section{Symbolic expression library}



%-------------------------------------------------------------------


% I want to define a function of a vector (momenta)
% 
% T[a_,b_,k_]:= k[a]k[b]/(k[-c]k[c])
% 
% How can I make it work even if instead of a single vector k I put in a 
% certain linear combination of vectors like 
% 
% p + 3q+42t
% 
% The naive solution produce k[a] -> (p + 3q+42t)[a] that is not equal to 
% p[a] + 3q[a]+42t[a].

\section{To resolve}

\begin{itemize}
\item  split toolkit-independent parts off from the gui (the cell tree,
  the manipulation of those cells, anything non-displaying)
\item scan through list of properties to see which ones should be
native.

\item It would make sense to be able to write
\begin{lstlisting}
  \conjugate{ \alpha_{n} \alpha_{m} }
\end{lstlisting}
and then apply the conjugation algorithm. Yes, this is precisely how
things should work: the programming language should know about the
algorithms, the data language should know about the operators. Systems
like sympy would immediately work this out. The above would be
declared as
\begin{lstlisting}
\dagger{#}::ConjugateTranspose.
\dagger{#}::DisplayAsSuperscript.
\end{lstlisting}
\item We need better logic to handle functional dependence like
\begin{lstlisting}
A_\mu(x)  and  A(x)_{\mu} .
\end{lstlisting}
Do we want to enforce the order of arguments (e.g. first functional
'indices', then vector space indices?).  Probably yes.

\item Get rid of different bracket types for grouping; this is rarely used and only
makes the system more complicated. Brackets should be displayed
whenever necessary, automatically. 

\item Calling algorithms from within C++. This should look as much as possible
as the Python version.

\item Making parameterised substitution rules, like 'replace riemann with metric' 
which is parameterised over the name of the metric.
\begin{lstlisting}
riemann_to_metric := R_{m n p q} -> \partial_{m n}{\1_{p q}} + ...
riemann_to_metric := R_{m n p q} -> \partial_{m n}{\g_{p q}} + ...
riemann_to_metric := R_{m n p q} -> \partial_{m n}{\{g}_{p q}} + ...
\end{lstlisting}
This would then actually just be parameterised expressions, and you could do
\begin{lstlisting}
a := \{var}_{m n}
b := @(a <- g) + @(a <- h)
b := @(a(g)) + @(a(h))
\end{lstlisting}

\item Resolve the issue of: we want to assign properties to patterns, but those patterns can 
depend on properties.

\item For long and recursive operations, it makes sense to be able to specify a simplification
algorithm to be called on every step, like Redberry does.

%   def simplify(ex):
%       sort\_product(ex)
%       collect\_terms(ex)
%      
% 
%   substitute(ex, 'A->B', simplify)
  
It would be fast to not make the round-trip through Python, but that
is probably premature optimisation because many people would want to
do more complicated things in the simplifier than just applying
algorithms in turn.

\item Make an inventory of all arguments passed to properties and algorithms.

\item online notebook viewer (for SSI)

\item component stuff is in general just: evaluate an expression
  making use of object->value substitutions. 

\begin{verbatim}
   ss_coords := \mu -> { t, r, \phi, \theta };
   ss_metric := { g_{t t} -> -f(r), g_{r r} -> 1/f(r), ... };
   ex := [e.g Riemann]
   evaluate(ex, values=[ss_coords, ss_metric] );
\end{verbatim}

\item independent components from young symmetry?

\end{itemize}


Relation between Young tableaux and highest-weight representations,
and also a discussion of tracelessness conditions, is in 

@article{Barut:1986dd,
      author         = "Barut, A.O. and Raczka, R.",
      title          = "{THEORY OF GROUP REPRESENTATIONS AND APPLICATIONS}",
      year           = "1986",
      SLACcitation   = "%%CITATION = INSPIRE-239743;%%",
}

\begin{verbatim}
P_A P_B = 0 but P_B P_A not=0 :
http://www.nbi.dk/~DasGroup/PUPress/120831Elvang.txt

SEE *** : http://particle.thep.lu.se/pub/Preprints/13/lu_tp_13_26.pdf
\end{verbatim}

\end{document}
