
# Substituting requires many dummy index relabelling. 
#
# Test 1: 'm' relabelling is triggered by a_{m} outside
#         'n' relabelling in second term ditto
#         'n' relabelling in first term because c_{pmn} -> c_{nmn} .

def test01():
    __cdbkernel__=create_scope()
    {d1,d2,d3,d4,m,n,p,r}::Indices(vector).
    obj1:= a_{m}*b_{n} + c_r b_r d_{m n};
    substitute(_, $b_{p} -> c_{p m n} A^{m n} + c_{p}$ );
    distribute(_);
    tst1:= a_{m} * c_{n d2 d1} * A^{d2 d1} + a_{m} * c_{n} + c_{r} * c_{r d1 d2} * A^{d1 d2} * d_{m n} + c_{r} * c_{r} * d_{m n} - @(obj1); 
    assert(tst1)
    print('Test 01 passed')

test01()

def test02():
    __cdbkernel__=create_scope()
    {m,n,p}::Indices(position=fixed).
    ex:= F_{m n} F^{m n};
    rl:= F_{m n} -> G_{m n};
    substitute(ex, rl)
    tst:= G_{m n} F^{m n} - @(ex);
    assert(tst)
    print('Test 02 passed')    

test02()

def test02b():
    # Product substitutions.
    __cdbkernel__=create_scope()
    {d1,d2,d3,d4,m,n,p,r,s,t,a,b}::Indices(vector).
    obj2:= a_{m n} * q * e * b_{m p} * o + d_{n p};
    substitute(obj2, $a_{r s} b_{r t} -> c_{s t}$ )
    tst2:= c_{n p} q e o + d_{n p} - @(obj2);
    assert(tst2)
    print('Test 02b passed')    

test02b()

def test02c():
    # Reducing to zero
    __cdbkernel__=create_scope()
    obj3:= A_{m n} B_{m n} k1_{a} k1_{a} k2_{b};
    substitute(_,  $k1_a k1_a -> 0$ )
    assert(obj3)
    print('Test 02c passed')    

test02c()
    
def test03():
    # Upper and lower indices replaced automagically.
    #
    # Side note: the replacement
    #    rl:= F_{m n} -> G_{m n} + H^{m n};
    # is tricky. A rule will be generated for all objects
    # matched on the lhs. So _m and _n to something. But on the rhs, that would
    # not normally match. Best to disallow these rules.
    __cdbkernel__=create_scope()
    {m,n,p,q}::Indices(position=free).
    ex:= F_{p q} F^{p q};
    rl:= F_{m n} -> G_{m n};
    substitute(ex, rl)
    rename_dummies(ex)
    tst2:= G_{m n} G^{m n} - @(ex);
    assert(tst2==0)
    print('Test 03 passed')
    
test03()

def test04():
    # Basic test of variational derivative.
    __cdbkernel__=create_scope()
    obj43:= A*B*A + D*E;
    vary(obj43, $A->C$)
    tst43:= C*B*A + A*B*C - @(obj43);
    assert(tst43)
    print('Test 04 passed')
    
test04()

def test04b():
    # Indices in the pattern.
    __cdbkernel__=create_scope()
    obj4:= A_m A_n + B_m C_n + D_{m n} A_p A_p;
    substitute(_, $A_a A_a -> q$ )
    tst4:= A_m A_n + B_m C_n + D_{m n} q - @(obj4);
    assert(tst4)
    print('Test 04b passed')
    
test04b()


def test05():
    # Variational derivative under Accents.
    __cdbkernel__=create_scope()
    \bar{?}::Accent.
    obj45:= \bar{A}*B*A;
    vary(obj45, $A -> C$)
    tst45:= \bar{C}*B*A + \bar{A}*B*C - @(obj45);
    assert(tst45)
    print('Test 05 passed')
    
test05()

def test06():
    # Nested substitutes.
    __cdbkernel__=create_scope()
    {a,b,c,d}::Indices.
    { \partial{#}, \partialp{#} }::PartialDerivative.
    A::Depends(\partial).
    B::Depends(\partialp).
    \Omega{#}::Derivative.
    obj46:= \Omega( \partial_{a}{A} )( \partialp_{b}{B} );
    rl:= \Omega( \partial_{a}{A??} )( B?? ) -> \partial_{a}{ \Omega(A??)(B??) };
    substitute(obj46, rl)
    tst46:= \partial_{a}{ \Omega(A)(\partialp_{b}{B}) } - @(obj46);
    assert(tst46)
    print('Test 06 passed')
    
test06()

def test07():
    # Vary multiple terms and single-factor terms.
    __cdbkernel__=create_scope()
    obj70:= A + B Q;
    vary(_, $A -> Q, B -> Z$ )
    tst70:= Q + Z Q - @(obj70);
    assert(tst70)
    print('Test 07 passed')
    
test07()

def test17():
    # Test 17: Object wildcards
    obj17:= [ A B, C];
    substitute(_, $[ M? N?, P? ] -> P? M? N?$ );
    tst17:= @(obj17) - C A B;
    assert(tst17)
    print('Test 17 passed')
    
test17()

def test84():
    # Bug reported Sun, 9 Nov 2014 15:51:05 +0800
    \partial{#}::PartialDerivative.
    yy:= a+ a*A;
    vary(yy, $A->\delta{A}$ )
    tst84:= a \delta{A} - @(yy);
    assert(tst84)
    print('Test 84 passed')

test84()

def test100():
    {\mu,\nu,\rho}::Indices(position=free).
    \partial{#}::PartialDerivative.
    ex:= \int{\partial_{\mu}{A_{\nu}} - \partial_{\nu}{A_{\mu}}}{x};
    vary(ex, $A_{\mu} -> \delta{A_{\mu}}$)
