
# Substituting requires many dummy index relabelling. 
#
# Test 1: 'm' relabelling is triggered by a_{m} outside
#         'n' relabelling in second term ditto
#         'n' relabelling in first term because c_{pmn} -> c_{nmn} .

def test01():
    __cdbkernel__=create_scope()
    {d1,d2,d3,d4,m,n,p,r}::Indices(vector).
    obj1:= a_{m}*b_{n} + c_r b_r d_{m n};
    substitute(_, $b_{p} -> c_{p m n} A^{m n} + c_{p}$ );
    distribute(_);
    tst1:= a_{m} * c_{n d2 d1} * A^{d2 d1} + a_{m} * c_{n} + c_{r} * c_{r d1 d2} * A^{d1 d2} * d_{m n} + c_{r} * c_{r} * d_{m n} - @(obj1); 
    collect_terms(_)
    assert(tst1)

test01()

def test02():
    __cdbkernel__=create_scope()
    {m,n,p}::Indices(position=fixed).
    ex:= F_{m n} F^{m n};
    rl:= F_{m n} -> G_{m n};
    substitute(ex, rl)
    tst:= G_{m n} F^{m n} - @(ex);
    assert(tst)

test02()
    
def test03():
    # This is a tricky replacment. A rule will be generated for all objects
    # matched on the lhs. So _m and _n to something. But on the rhs, that would
    # not normally match. Best to disallow these rules.
    #rl:= F_{m n} -> G_{m n} + H^{m n};
    __cdbkernel__=create_scope()
    {m,n,p,q}::Indices(position=free).
    ex:= F_{p q} F^{p q};
    rl:= F_{m n} -> G_{m n};
    substitute(ex, rl)
    rename_dummies(ex)
    tst2:= G_{m n} G^{m n} - @(ex);
    assert(tst2==0)

test03()

def test04():
    # Basic test of variational derivative.
    __cdbkernel__=create_scope()
    obj43:= A*B*A + D*E;
    vary(obj43, $A->C$)
    tst43:= C*B*A + A*B*C - @(obj43);
    assert(tst43)

test04()

def test05():
    # Variational derivative under Accents.
    __cdbkernel__=create_scope()
    \bar{?}::Accent.
    obj45:= \bar{A}*B*A;
    vary(obj45, $A -> C$)
    tst45:= \bar{C}*B*A + \bar{A}*B*C - @(obj45);
    assert(tst45)

test05()

def test06():
    # Nested substitutes.
    __cdbkernel__=create_scope()
    {a,b,c,d}::Indices.
    { \partial{#}, \partialp{#} }::PartialDerivative.
    A::Depends(\partial).
    B::Depends(\partialp).
    \Omega{#}::Derivative.
    obj46:= \Omega( \partial_{a}{A} )( \partialp_{b}{B} );
    rl:= \Omega( \partial_{a}{A??} )( B?? ) -> \partial_{a}{ \Omega(A??)(B??) };
    substitute(obj46, rl)
    tst46:= \partial_{a}{ \Omega(A)(\partialp_{b}{B}) } - @(obj46);
    assert(tst46)

test06()

def test07():
    # Vary multiple terms and single-factor terms.
    __cdbkernel__=create_scope()
    obj70:= A + B Q;
    vary(_, $A -> Q, B -> Z$ )
    tst70:= Q + Z Q - @(obj70);
    assert(tst70)

test07()

