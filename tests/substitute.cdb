
# Substituting requires many dummy index relabelling. 
#
# Test 1: 'm' relabelling is triggered by a_{m} outside
#         'n' relabelling in second term ditto
#         'n' relabelling in first term because c_{pmn} -> c_{nmn} .

def test01():
    {d1,d2,d3,d4,m,n,p,r}::Indices(vector).
    obj1:= a_{m}*b_{n} + c_r b_r d_{m n};
    substitute(_, $b_{p} -> c_{p m n} A^{m n} + c_{p}$ );
    distribute(_);
    tst1:= a_{m} * c_{n d2 d1} * A^{d2 d1} + a_{m} * c_{n} + c_{r} * c_{r d1 d2} * A^{d1 d2} * d_{m n} + c_{r} * c_{r} * d_{m n} - @(obj1); 
    collect_terms(_)
    assert(tst1)

test01()

def test02():
    {m,n,p}::Indices(position=fixed).
    ex:= F_{m n} F^{m n};
    rl:= F_{m n} -> G_{m n};
    substitute(ex, rl)
    tst:= G_{m n} F^{m n} - @(ex);
    assert(tst)

test02()
    
def test03():
    # This is a tricky replacment. A rule will be generated for all objects
    # matched on the lhs. So _m and _n to something. But on the rhs, that would
    # not normally match. Best to disallow these rules.
    #rl:= F_{m n} -> G_{m n} + H^{m n};
    {m,n,p,q}::Indices(position=free).
    ex:= F_{p q} F^{p q};
    rl:= F_{m n} -> G_{m n};
    substitute(ex, rl)
    print(ex)
    tst2:= G_{m n} G^{m n} - @(ex);
    assert(tst2==0)

#test03()
