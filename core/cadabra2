#!/usr/bin/python

import sys
import site
from code import InteractiveConsole
import code
import re
import readline
import rlcompleter
import os

from cadabra2 import *

class FileCacher:
    "Cache the stdout text so we can analyze it before returning it"
    def __init__(self): self.reset()
    def reset(self): self.out = []
    def write(self,line): self.out.append(line)
    def flush(self):
#        output = '\n'.join(self.out)
        output=self.out
        self.reset()
        return output


class Shell(InteractiveConsole):
    "Wrapper around Python that can filter input/output to the shell"
    def __init__(self):
        self.stdout = sys.stdout
        self.cache = FileCacher()
#        readline.set_completer(rlcompleter.Completer(vars).complete)
        InteractiveConsole.__init__(self)
        return

    # If the object to be displayed is an Ex (add Property), print it
    # using the human-readable str (FIXME: add other printers). If not,
    # pass it on to the previously existing display hook.
    def _displayhook(self, arg):
        if isinstance(arg, Ex):
            print(str(arg))
        elif isinstance(arg, Property):
            print(str(arg))
        else:
            self.remember_display_hook(arg)

            
    # Setup hooks for pretty printing.
    def set_display(self):
        self.remember_display_hook = sys.displayhook
        sys.displayhook = self._displayhook

    def unset_display(self):
        sys.displayhook = self.remember_display_hook


    def get_output(self): sys.stdout = self.cache
    def return_output(self): sys.stdout = self.stdout

    # Detect Cadabra expression statements and rewrite to Python
    # form. The logic is that any expression ending on ';' or '.' is not
    # going to be a valid/recommended Python expression, so we turn it
    # into a declaration of an Ex object or property.
    # Detect Cadabra property declarations and rewrite to Python form.
    # todo: make ';' at the end result in an additional print (and
    # make the print statement print property objects using their
    # readable form; addresses one issue report).

    def preprocess(self, line):
        # print '='+line+"=="
        imatch = re.search('([\s]*)([^\s].*[^\s])([\s]*)', line)
        if imatch:
            indent_line=imatch.group(1)
            end_of_line=imatch.group(3)
        else:
            indent_line=""
            end_of_line="\n"
        line_stripped=line.rstrip().lstrip()
        # print '='+line_stripped+"=="
        lastchar = line_stripped[-1:]
        if lastchar=='.' or lastchar==';':
            line_stripped=line_stripped[:-1]
        found = line_stripped.find(':=')
        if found>0:
            rewrite = indent_line + line_stripped[:found] + " = Ex(r'" + line_stripped[found+2:]+"')"
            objname=line_stripped[:found]
            if lastchar!='.' and len(indent_line)==0:
                rewrite = rewrite + "; print " + objname
            line=rewrite
        else:
            # Is it a property declaration?
            found = line_stripped.find('::')
            if found>0:
                match = re.search('([a-zA-Z]*)(.*)', line_stripped[found+2:])
                if match:
                    if len(match.group(2))>0: # declaration with arguments
                        rewrite = indent_line + "__cdbtmp__ = "+match.group(1)+"(Ex(r'"+line_stripped[:found]+"'), Ex('"+match.group(2)[1:-1]+"') )"
                    else:
                        rewrite = indent_line + "__cdbtmp__ = "+line_stripped[found+2:]+"(Ex(r'"+line_stripped[:found]+"'))"
                    objname="__cdbtmp__"
                    # print the expression if we are at top level (not in a function) and the last char is not '.'
                    if lastchar!='.' and len(indent_line)==0:
                        rewrite = rewrite + "; print " + objname
                    line=rewrite
                else:
                    print "inconsistent" # property names can only contain letters
            else:
                line=indent_line+line_stripped
        return line+end_of_line

    def push(self,line):

        line = self.preprocess(line)
        # print 'executing: ', line

        # Now feed the pre-parsed input to Python.
        self.get_output()
        ret=InteractiveConsole.push(self,line)
        self.return_output()
        output = self.cache.flush()
        for line in output:
            sys.stdout.write(line)
        return ret

if __name__ == '__main__':
    sh = Shell()
    sys.ps1='> '
    sys.ps2='. '

    if len(sys.argv)>1:
        if '-d' in sys.argv:
            rs = "gdb -q -ex r --args python "+sys.argv[0];
            for a in sys.argv[1:]:
                if a!='-d':
                    rs += " "+a
            os.system(rs)
        else:
            execfile(site.getsitepackages()[0]+'/cadabra2_defaults.py');
            sh2 = InteractiveConsole()
            with open(sys.argv[1]) as f:
                collect=""
                for line in f:
                    sline=line.strip()
                    if len(sline)>0 and sline[0]!='#':
                        collect += sh.preprocess(line)
                # print "----\n"+collect+"----\n"
                cmp = compile(collect, sys.argv[1], 'exec')
                exec(cmp)
                # would be nice to be able to continue from here on the command line, but that requires
                # pulling in the right locals/globals
                #            sh.interact(banner='Info at http://cadabra.phi-sci.com/\nAvailable under the terms of the GNU General Public License v3\n', locals(), globals())
    else:
        sh.runsource("print 'Cadabra 2.0 pre-release'; print 'Copyright (C) 2001-2015  Kasper Peeters <kasper.peeters@phi-sci.com>'; import site; execfile(site.getsitepackages()[0]+'/cadabra2_defaults.py'); print 'Using sympy version '+sympy.__version__;")
        sh.interact(banner='Info at http://cadabra.phi-sci.com/\nAvailable under the terms of the GNU General Public License v3\n')
