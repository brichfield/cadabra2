
- Checking conditions needs to be part of match_subproduct, because it will
  otherwise only attempt the first two factors if the condition fails there.

- state: from checkpointed -> unchanged -> changed / error. Rename.

- expression ordering needs to keep equal objects with different parent rels next to each
  other, but doesn't yet (Compare.cc; child comparison should move up). This will break
  index relabeling with composite dummies.

- Several display functions assume that they never get called on \operator{#} type 
  expressions, and then segfault. \pow has been fixed, sort-of, but this needs looking into.

- Document DOCME in Props.cc, about how Indices properties get stored.

- \conditional and -> have the right relative priority, but \conditional and = do not.  Although
  we probably want to keep it that way, because otherwise you cannot write m=n in a conditional,
  and have to do things like m==n.

- replace_match and take_match are still rough around the edges; need to be forced to work only
  at top level, or we need to store the replacement points more cleverly, or...

http://jupyter-client.readthedocs.org/en/latest/kernels.html#kernelspecs :

{
 "argv": ["cadabra-server", "--jupyter", "{connection_file}"],
 "display_name": "Cadabra",
 "language": "cadabra"
}

gets a connection spec

{
  "control_port": 50160,
  "shell_port": 57503,
  "transport": "tcp",
  "signature_scheme": "hmac-sha256",
  "stdin_port": 52597,
  "hb_port": 42540,
  "ip": "127.0.0.1",
  "iopub_port": 40885,
  "key": "a0436f6c-1916-498b-8eb9-e81ab9368e84"
}

- spinorsort missing
  Coordinate man page needs better help
  Depends does not behave as stated in the manual page (and Depends(\partial) leads to a crash).
  CommutingAsProduct should be written with comma-separated arguments and the parser should then
    convert that to individual children.
  DAntiSymmetric man page requires impose_bianchi.
  Accent should be cleaned up. It is questionable whether one should make a blanket PropertyInherit
    instead of doing things one-by-one; it is too likely to go wrong somewhere. But what does Accent
    then do more than IndexInherit? It _IS_ important for typesetting, \hat{A} should not turn
    to \hat(A). Accent also occurs in PythonCdb.cc 
  FilledTableau cannot be typeset online.
  KroneckerDelta does not have an example (and eliminate_kronecker should be eliminate_delta).
  SatisfiesBianchi example crashes.

  Indices: add 'Indices are symbols attached to other symbols by a
  sub- or superscript relation. They can carry a numerical coefficient
  as well, so $A_{-n}$ contains an index '$-n$'. 

- check_index_consistency is not called when an Ex is created. Fix IndexInherit.cnb after fixing this.

- CTRL-delete is a bad way to delete a cell (coincides with emacs delete word)

- Manual pages need <title>

- expand_delta does not yet do things as clever as it could.

- OS X autolayout: http://blog.bjhomer.com/2014/08/nsscrollview-and-autolayout.html

- maybe pass a python list of objects to factor_in ?

- set_overlays_scrolling: disable if present (requires recompiling gtkmm)

- positioning cursor does the wrong thing when there is an error cell (jumps to after the error cell).

- include examples of car56.pdf

- display should work on the command line as well; it refers to server which then breaks.

- Reset kernel on loading a new notebook: fix reporting of kernel run status.

- A_{m n} property does not match A^{m n} object in expression even
  when index positions are free.

- Resizing window does not relayout TeX cells (garbage images result).

- Copy mathjax to local.

- Decide on how to output \components so we can start writing tests.

- We have two ways to represent tensor components: as rules, and as \component nodes.
  These should ideally be merged into one. Or not?

- Move all doc/developers/* to doxygen.

- installation needs to run texhash to pickup tableaux.sty

- Declaring Accent for a LaTeX operator leads to problems in output; make
  it actually act on something before displaying.

- Join lists of substitution rules. This is an algorithm which does _not_ modify an expression
  but insteads spits out a new one; need some general logic on how this fits in with the
  standard cdb algorithms. It is a bit like joining \components nodes; see above.

- For some tensors we would like to indicate to evaluate that it should keep all components. 

- Declaring ::Metric should declare InverseMetric.

- Remove all asserts and replace with exceptions.

- DisplaySympy::import should strip implicit dependencies from objects.

- Cleanup should not use algorithms to prevent recursion and (more importantly) to 
  make clear in one place what the algorithms do.

- ComputeThread should not insert \color and probably also not \verbatim, as that
  is dependent on the output mode.

- Could we flip CodeInput cells to produce Python previews with formulas LaTeX typeset?

- declaring an Ex does not call post_process

- output cells should dim when input cells go into the run queue.

- substitute should by default, when it encounters an \equal top node, only act
  on the right hand side. It should also, when encountering an object without an
  \equal top node, construct an \equal node with the original expression on the
  lhs. Evaluate should by default only act on the rhs of an \equal.

  This way you can do

     ex:= R^{\mu}_{\no\rho\sigma};

  and then subsequently
  
     substitute(ex, RtoGamma)
     ex:= R^{\mu}_{\no\rho\sigma} = \partial_{}{\Gamma..}
     substitute(ex, GammaToG)
     ex:= R^{\mu}_{\no\rho\sigma} = \partial_{...}{g_{..}} 
     evaluate(ex, ss);
     ex:= R^{\mu}_{\no\rho\sigma} = \begin{cases}...\end{cases}

  However this does get clumsy when you act on a longish expression and do not
  want to see it constantly printed in its original form. 

- For the example notebooks we need default rules back.

- GammaMatrix with two identical indices does not canonicalise to zero.

- Export to LaTeX and then once that works, to PDF.

- CodeInput changes should be monitored by monitoring the change of the buffer. This is also
  necessary because cut-n-paste does not induce keypresses.

- Need split cell urgently.

- Having access to an index accessor for Ex would be useful for debugging; e.g. ex[3][1] and so on.

- To show the original expression when evaluating components, we could let evaluate make a 
  copy of the original, do substitute and eval on the copy, then add the result as a components
  child to the original.

- Does it make sense, instead of pulling e.g. sympy.simplify into simplify, to instead make
  'simplify' act on the existing expression and simplify in-place, like the other cadabra
  algorithms?

- ex:=A(f(r), r);

  does not print correctly: it leads to 

  A((f(r), r))

  This is not easy to get right, because the tree is
  
    A
     \comma
        f 
         (r)
        r

  and this could mean both A(f(r),r) or A({f(r),r}). NO THAT's not true; in my tree,
  A(f(r),r) SHOULD BE (but the parser gets this wrong)

    A
      f
        r
      r

  without the comma, because separate arguments become separate children of the main node.
  So we can ALWAYS drop the round brackets.

- Display of component tensors in matrix or nested matrix form.

- substitute needs a flag to determine whether or not components can be matched to abstract indices.

- replace_index has changed logic; do a grep to see if this requires changes.

- The replacement_map should only match exact expressions (not modulo
  parent rel, because we stick that in explicitly). However, the
  subtree_compare does not have an option to turn mod_prel off. We
  turned it off now, but this may break other things.

- LaTeXForm needs cleaning up and catching errors.

- Exceptions should have a way to print Ex objects without knowing what the backend is, so
  we can print error messages in an appropriate way. 

- substitute handles sums on the lhs, but these need to match to full
  sums in the pattern, not partial sums. For products we can match
  sub-products, so we should have a match for sub-sums as well.

- Property initialisation from Python, and in particular how the
  key/val pairs get set, should be documented, fixed and fed through to e.g. LaTeXForm.
  Right now we do not do any of that, correct?

- Need a better way to pretty-print lists, as the default str() does not
  look nice when fed through \begin{verbatim}...\end{verbatim}.

- Ex_to_Sympy should be finished: no free/dummy index check.

- Replace \prod -> \mult and \sum -> \add ?  Makes sense from LaTeX perspective.
  Also \comma -> \list ?

- Need to document the allowed structure of reserved nodes
  
    PartialDerivative: at most one non-index node.
    \sum:  has to have unit multiplier.
    \prod: all children have to have unit multiplier.
	 \components: has to have unit multiplier.

- Might want to introduce a cache for evaluate, so that when we see a pattern, 
  we know what \components node to replace it with.

- Need a matcher in substitute which indicates that an object was matched but with indices
  in the wrong position, and which then automatically inserts a metric by looking at the
  metric=g type of attribute on Indices. How do we do this for component values to be most
  efficient?

- notebook->html creates incorrect html for error cells, which trips clay/jinja2 
  with TemplateSyntaxError: Missing end of comment tag


- compute->stop() does stop, but the notebook does not update the cell
  status, and it does not set cells to 'not evaluating'.

- Stop button does not always get greyed out.

- if on_failed is called in the client, we need to produce a useful
  error message; see docs of websocket.

- connections to localhost with networking enabled but without active
  net connection are still broken.

- Plots need to scale with hiDPI settings. Minimal size of window should do the same.

- large output of arrays makes latex barf.

- handle the popen file pointer more gracefully.

- If a kernel which was started by the client notices that the client
  goes away because the socket was closed, terminate the kernel.

- Write in docs that the only way to get output is to either just print things
  and get them displayed verbatim, or to call 'display' on an object and let the
  smart display routines figure out how to encode the object in a JSON message.
  The ';' shorthand should then add a 'display' wrapping the entire line?

    ex:=A_{m n}; 

  turns into

    ex=Ex('A_{m n}'); display(ex)

  Maybe take everything up to a (not necessarily present) equals sign.

- When a large output cell gets generated, we need to make sure that after the
  output is inserted, we scroll the document such that the cursor is at the
  same screen position.

- When current_cell is set/unset, update the menu so that actions acting on 
  the current cell are enabled/disabled.

- Add code to split/merge input cells.




- Work out examples of tensor product decomposition with numerical index values to
  see how it works. We do not seem to have a complete implementation yet, as the
  VEST identities should be derivable, but they do not work yet (the free index 
  stays free).

  It is of course in the end all a generalisation of symm + antisymm.

- cleanup_nests is not following the rule that nothing below the iterator
  is allowed to change. 

- core status: next: pass varying arguments to algorithms.

- add kernel starting/restarting logic to ComputeThread

- gui status: document logic

- For ActionRemoveCell we need to flip the order of remove gui and execute on doc,   
  or not? Depends on whether we keep the cell floating alive outside the Doc or not.

- client_server: we need to lock the tree during an entire loop of process_action_queue,
  and not lock explicitly in Actions.


- server: We want a cleaner description of the output type of a cell. This seems to 
  require that we are able to split the input up into individual expressions, so that
  we can then declare the output of a cell as a list, with each expression being one
  element in that list. 
  https://github.com/ipython/ipython/blob/master/IPython/core/inputsplitter.py

  got it: print produces a 'text' output, other evaluations of objects produce their
  respective data types. All go together into a list. Output of a cell can be suppressed
  by a cell-local flag.

  IPython does something similar, e.g. if you return a Math(...) object things get
  displayed using a TeX typesetter. It also allows objects to define _repr_png_ and
  _repr_latex_ methods that convert themselves to those data types. Those objects
  seem to get put on the wire with a mime type followed by raw data.

  In order to be language agnostic, these data types need to be defined without reference
  to python. Every language kernel needs to be able to put objects of these types on
  the wire, and also ** read them back in **. How do we do the latter with code segments?
  How do we handle input into cells?

  All cells should have inputs, outputs and a visual representation. IPython makes it 
  needlessly complicated by pretending that widgets are somehow different from other cells.
  Our CodeInput cells are simply cells with input being a python context, output being
  the context plus our input, and visual representation being the editor where 'ctrl-enter' is
  'feed output'.

- test case: compute geodesic in ss as function of initial angle, and then do an 
  interactive solve based on that initial angle. 

- for comparison of sage and ipython:
  http://blog.fperez.org/2012/01/ipython-notebook-historical.html


- plots: https://github.com/jakevdp/mpld3 first lets matplotlib make a plot. It then
  uses https://github.com/mpld3/mplexporter to convert the plot object to a json
  representation, and feeds that to the browser. Once it is there, a d3.js based
  viewer displays the json data in graphical form. Deep...


- IPython's QtConsole has the logic that everything that you want to
  output needs to be wrapped in a 'display' call. We do something similar already, but
  with 'print' (nothing reaches the output channel automatically). Using 'display' or
  perhaps 'cadabra.display' to be unambiguous has some advantages because we can 
  ensure that we output a proper mime type like identifier with the output.

- Change ComputeThread so that it does not need access to anything but isolated DataCells.
  Perhaps not let it change them either, and pass everything by const ref. However, that 
  makes it impossible to set the 'running' flag.


GTKMM:
======

- we store widgets in 'visualcells', and then also add them to gtkmm containers. how does ownership work here?

OSX:
====

- build settings contains explicit ref to /usr/local/Cellar/1.56.0/boost/include/
- websocketpp copied into tree, not yet checked in.



