
- installation needs to run texhash to pickup tableaux.sty

- Need some general logic to compute one object from another (inverse metric from metric being
  the prime example).

- Remove all asserts and replace with exceptions.

- DisplaySympy::import should strip implicit dependencies from objects.

- Cleanup should not use algorithms to prevent recursion and (more importantly) to 
  make clear in one place what the algorithms do.

- Could we flip CodeInput cells to produce Python previews with formulas LaTeX typeset?

- declaring an Ex does not call post_process

- output cells should dim when input cells go into the run queue.

- substitute should by default, when it encounters an \equal top node, only act
  on the right hand side. It should also, when encountering an object without an
  \equal top node, construct an \equal node with the original expression on the
  lhs. Evaluate should by default only act on the rhs of an \equal.

  This way you can do

     ex:= R^{\mu}_{\no\rho\sigma};

  and then subsequently
  
     substitute(ex, RtoGamma)
     ex:= R^{\mu}_{\no\rho\sigma} = \partial_{}{\Gamma..}
     substitute(ex, GammaToG)
     ex:= R^{\mu}_{\no\rho\sigma} = \partial_{...}{g_{..}} 
     evaluate(ex, ss);
     ex:= R^{\mu}_{\no\rho\sigma} = \begin{cases}...\end{cases}

  However this does get clumsy when you act on a longish expression and do not
  want to see it constantly printed in its original form. 

- For the example notebooks we need default rules back.

- GammaMatrix with two identical indices does not canonicalise to zero.

- Export to LaTeX and then once that works, to PDF.

- Need to get rid of fl.bracket field; bracket types for grouping
  should always be converted to round and determined by printing
  routines. This avoids 1/{A*B} not being 1/(A*B). We can fix this easily in the
  parser by replacing b_round -> b_none, but then the printing routines should
  be so clever to output round brackets for function arguments.

- CodeInput changes should be monitored by monitoring the change of the buffer. This is also
  necessary because cut-n-paste does not induce keypresses.

- Need split cell urgently.

- Having access to an index accessor for Ex would be useful for debugging; e.g. ex[3][1] and so on.

- Sympy can invert matrices so automatically generate rules for an inverse metric. We
  could trigger generation of an inverse matrix as soon as someone specifies the components
  of a metric and the expression contains its inverse (or the other way around).

- To show the original expression when evaluating components, we could let evaluate make a 
  copy of the original, do substitute and eval on the copy, then add the result as a components
  child to the original.

- Does it make sense, instead of pulling e.g. sympy.simplify into simplify, to instead make
  'simplify' act on the existing expression and simplify in-place, like the other cadabra
  algorithms?

- ex:=A(f(r), r);

  does not print correctly: it leads to 

  A((f(r), r))

  This is not easy to get right, because the tree is
  
    A
     \comma
        f 
         (r)
        r

  and this could mean both A(f(r),r) or A({f(r),r}).

- Display of component tensors in matrix or nested matrix form.

- substitute needs a flag to determine whether or not components can be matched to abstract indices.

- check_index_consistency is not called when an Ex is created.

- replace_index has changed logic; do a grep to see if this requires changes.

- The replacement_map should only match exact expressions (not modulo
  parent rel, because we stick that in explicitly). However, the
  subtree_compare does not have an option to turn mod_prel off. We
  turned it off now, but this may break other things.

- LaTeXForm needs cleaning up and catching errors.

- Exceptions should have a way to print Ex objects without knowing what the backend is, so
  we can print error messages in an appropriate way. 

- substitute handles sums on the lhs, but these need to match to full
  sums in the pattern, not partial sums. For products we can match
  sub-products, so we should have a match for sub-sums as well.

- Property initialisation from Python, and in particular how the
  key/val pairs get set, should be documented, fixed and fed through to e.g. LaTeXForm.
  Right now we do not do any of that, correct?

- Need a better way to pretty-print lists, as the default str() does not
  look nice when fed through \begin{verbatim}...\end{verbatim}.

- Ex_to_Sympy should be finished: no free/dummy index check.

- Replace \prod -> \mult and \sum -> \add ?  Makes sense from LaTeX perspective.
  Also \comma -> \list ?

- Need to document the allowed structure of reserved nodes
  
    PartialDerivative: at most one non-index node.
    \sum:  has to have unit multiplier.
    \prod: all children have to have unit multiplier.
	 \components: has to have unit multiplier.

- Might want to introduce a cache for evaluate, so that when we see a pattern, 
  we know what \components node to replace it with.

- Need a matcher in substitute which indicates that an object was matched but with indices
  in the wrong position, and which then automatically inserts a metric by looking at the
  metric=g type of attribute on Indices. How do we do this for component values to be most
  efficient?

- notebook->html creates incorrect html for error cells, which trips clay/jinja2 
  with TemplateSyntaxError: Missing end of comment tag


- compute->stop() does stop, but the notebook does not update the cell
  status, and it does not set cells to 'not evaluating'.

- Stop button does not always get greyed out.

- if on_failed is called in the client, we need to produce a useful
  error message; see docs of websocket.

- connections to localhost with networking enabled but without active
  net connection are still broken.

- Plots need to scale with hiDPI settings. Minimal size of window should do the same.

- large output of arrays makes latex barf.

- Catch TeXEngine exceptions in the frontend.


- Components: finish the substitute compare method so it can match
  A_{t r} to the expression A_{m n} and then return the so-matched set.

- handle the popen file pointer more gracefully.

- If a kernel which was started by the client notices that the client
  goes away because the socket was closed, terminate the kernel.

- Reset kernel on loading a new notebook.

- Write in docs that the only way to get output is to either just print things
  and get them displayed verbatim, or to call 'display' on an object and let the
  smart display routines figure out how to encode the object in a JSON message.
  The ';' shorthand should then add a 'display' wrapping the entire line?

    ex:=A_{m n}; 

  turns into

    ex=Ex('A_{m n}'); display(ex)

  Maybe take everything up to a (not necessarily present) equals sign.

- When a large output cell gets generated, we need to make sure that after the
  output is inserted, we scroll the document such that the cursor is at the
  same screen position.

- When current_cell is set/unset, update the menu so that actions acting on 
  the current cell are enabled/disabled.

- Add code to split/merge input cells.




- Work out examples of tensor product decomposition with numerical index values to
  see how it works. We do not seem to have a complete implementation yet, as the
  VEST identities should be derivable, but they do not work yet (the free index 
  stays free).

  It is of course in the end all a generalisation of symm + antisymm.

- cleanup_nests is not following the rule that nothing below the iterator
  is allowed to change. 

- core status: next: pass varying arguments to algorithms.

- add kernel starting/restarting logic to ComputeThread

- gui status: document logic

- For ActionRemoveCell we need to flip the order of remove gui and execute on doc,   
  or not? Depends on whether we keep the cell floating alive outside the Doc or not.

- client_server: we need to lock the tree during an entire loop of process_action_queue,
  and not lock explicitly in Actions.


- server: We want a cleaner description of the output type of a cell. This seems to 
  require that we are able to split the input up into individual expressions, so that
  we can then declare the output of a cell as a list, with each expression being one
  element in that list. 
  https://github.com/ipython/ipython/blob/master/IPython/core/inputsplitter.py

  got it: print produces a 'text' output, other evaluations of objects produce their
  respective data types. All go together into a list. Output of a cell can be suppressed
  by a cell-local flag.

  IPython does something similar, e.g. if you return a Math(...) object things get
  displayed using a TeX typesetter. It also allows objects to define _repr_png_ and
  _repr_latex_ methods that convert themselves to those data types. Those objects
  seem to get put on the wire with a mime type followed by raw data.

  In order to be language agnostic, these data types need to be defined without reference
  to python. Every language kernel needs to be able to put objects of these types on
  the wire, and also ** read them back in **. How do we do the latter with code segments?
  How do we handle input into cells?

  All cells should have inputs, outputs and a visual representation. IPython makes it 
  needlessly complicated by pretending that widgets are somehow different from other cells.
  Our CodeInput cells are simply cells with input being a python context, output being
  the context plus our input, and visual representation being the editor where 'ctrl-enter' is
  'feed output'.

- test case: compute geodesic in ss as function of initial angle, and then do an 
  interactive solve based on that initial angle. 

- for comparison of sage and ipython:
  http://blog.fperez.org/2012/01/ipython-notebook-historical.html


- plots: https://github.com/jakevdp/mpld3 first lets matplotlib make a plot. It then
  uses https://github.com/mpld3/mplexporter to convert the plot object to a json
  representation, and feeds that to the browser. Once it is there, a d3.js based
  viewer displays the json data in graphical form. Deep...


- IPython's QtConsole has the logic that everything that you want to
  output needs to be wrapped in a 'display' call. We do something similar already, but
  with 'print' (nothing reaches the output channel automatically). Using 'display' or
  perhaps 'cadabra.display' to be unambiguous has some advantages because we can 
  ensure that we output a proper mime type like identifier with the output.

- Change ComputeThread so that it does not need access to anything but isolated DataCells.
  Perhaps not let it change them either, and pass everything by const ref. However, that 
  makes it impossible to set the 'running' flag.


GTKMM:
======

- we store widgets in 'visualcells', and then also add them to gtkmm containers. how does ownership work here?

OSX:
====

- build settings contains explicit ref to /usr/local/Cellar/1.56.0/boost/include/
- websocketpp copied into tree, not yet checked in.



