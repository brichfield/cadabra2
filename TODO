
- Catch TeXEngine exceptions in the frontend.

- Components: finish the substitute compare method so it can match
  A_{t r} to the expression A_{m n} and then return the so-matched set.

- handle the popen file pointer more gracefully.

- If a kernel which was started by the client notices that the client
  goes away because the socket was closed, terminate the kernel.

- Reset kernel on loading a new notebook.

- Write in docs that the only way to get output is to either just print things
  and get them displayed verbatim, or to call 'display' on an object and let the
  smart display routines figure out how to encode the object in a JSON message.
  The ';' shorthand should then add a 'display' wrapping the entire line?

    ex:=A_{m n}; 

  turns into

    ex=Ex('A_{m n}'); display(ex)

  Maybe take everything up to a (not necessarily present) equals sign.

- When a large output cell gets generated, we need to make sure that after the
  output is inserted, we scroll the document such that the cursor is at the
  same screen position.

- When current_cell is set/unset, update the menu so that actions acting on 
  the current cell are enabled/disabled.

- Add code to split/merge input cells.




- Work out examples of tensor product decomposition with numerical index values to
  see how it works. We do not seem to have a complete implementation yet, as the
  VEST identities should be derivable, but they do not work yet (the free index 
  stays free).

  It is of course in the end all a generalisation of symm + antisymm.

- cleanup_nests is not following the rule that nothing below the iterator
  is allowed to change. 

- core status: next: pass varying arguments to algorithms.

- add kernel starting/restarting logic to ComputeThread

- gui status: document logic

- For ActionRemoveCell we need to flip the order of remove gui and execute on doc,   
  or not? Depends on whether we keep the cell floating alive outside the Doc or not.

- client_server: we need to lock the tree during an entire loop of process_action_queue,
  and not lock explicitly in Actions.


- server: We want a cleaner description of the output type of a cell. This seems to 
  require that we are able to split the input up into individual expressions, so that
  we can then declare the output of a cell as a list, with each expression being one
  element in that list. 
  https://github.com/ipython/ipython/blob/master/IPython/core/inputsplitter.py

  got it: print produces a 'text' output, other evaluations of objects produce their
  respective data types. All go together into a list. Output of a cell can be suppressed
  by a cell-local flag.

  IPython does something similar, e.g. if you return a Math(...) object things get
  displayed using a TeX typesetter. It also allows objects to define _repr_png_ and
  _repr_latex_ methods that convert themselves to those data types. Those objects
  seem to get put on the wire with a mime type followed by raw data.

  In order to be language agnostic, these data types need to be defined without reference
  to python. Every language kernel needs to be able to put objects of these types on
  the wire, and also ** read them back in **. How do we do the latter with code segments?
  How do we handle input into cells?

  All cells should have inputs, outputs and a visual representation. IPython makes it 
  needlessly complicated by pretending that widgets are somehow different from other cells.
  Our CodeInput cells are simply cells with input being a python context, output being
  the context plus our input, and visual representation being the editor where 'ctrl-enter' is
  'feed output'.

- test case: compute geodesic in ss as function of initial angle, and then do an 
  interactive solve based on that initial angle. 

- for comparison of sage and ipython:
  http://blog.fperez.org/2012/01/ipython-notebook-historical.html


- plots: https://github.com/jakevdp/mpld3 first lets matplotlib make a plot. It then
  uses https://github.com/mpld3/mplexporter to convert the plot object to a json
  representation, and feeds that to the browser. Once it is there, a d3.js based
  viewer displays the json data in graphical form. Deep...


- IPython's QtConsole has the logic that everything that you want to
  output needs to be wrapped in a 'display' call. We do something similar already, but
  with 'print' (nothing reaches the output channel automatically). Using 'display' or
  perhaps 'cadabra.display' to be unambiguous has some advantages because we can 
  ensure that we output a proper mime type like identifier with the output.

- Change ComputeThread so that it does not need access to anything but isolated DataCells.
  Perhaps not let it change them either, and pass everything by const ref. However, that 
  makes it impossible to set the 'running' flag.


GTKMM:
======

- we store widgets in 'visualcells', and then also add them to gtkmm containers. how does ownership work here?

OSX:
====

- build settings contains explicit ref to /usr/local/Cellar/1.56.0/boost/include/
- websocketpp copied into tree, not yet checked in.



